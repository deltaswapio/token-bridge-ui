{"version":3,"file":"static/js/586.a8bd81f7.chunk.js","mappings":"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","sources":["../node_modules/@ledgerhq/cryptoassets/src/data/evm/index.ts","../node_modules/@ledgerhq/domain-service/src/registries/index.ts","../node_modules/@ledgerhq/domain-service/src/signers/index.ts","../node_modules/@ledgerhq/domain-service/src/utils/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/contracts.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/erc20.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/loadConfig.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/nfts.ts","../node_modules/@ledgerhq/hw-app-eth/src/utils.ts"],"sourcesContent":["import arbitrum_tokens from \"./42161/erc20.json\";\nimport arbitrum_goerli_tokens from \"./421613/erc20.json\";\nimport astar_tokens from \"./592/erc20.json\";\nimport base_goerli_tokens from \"./84531/erc20.json\";\nimport bittorrent_tokens from \"./199/erc20.json\";\nimport bsc_tokens from \"./56/erc20.json\";\nimport cronos_tokens from \"./25/erc20.json\";\nimport energy_web_tokens from \"./246/erc20.json\";\nimport ethereum_tokens from \"./1/erc20.json\";\nimport ethereum_goerli_tokens from \"./5/erc20.json\";\nimport ethereum_rinkeby_tokens from \"./4/erc20.json\";\nimport ethereum_ropsten_tokens from \"./3/erc20.json\";\nimport ethereum_sepolia_tokens from \"./11155111/erc20.json\";\nimport fantom_tokens from \"./250/erc20.json\";\nimport flare_tokens from \"./14/erc20.json\";\nimport klaytn_tokens from \"./8217/erc20.json\";\nimport metis_tokens from \"./1088/erc20.json\";\nimport moonbeam_tokens from \"./1284/erc20.json\";\nimport optimism_tokens from \"./10/erc20.json\";\nimport optimism_goerli_tokens from \"./420/erc20.json\";\nimport polygon_tokens from \"./137/erc20.json\";\nimport polygon_zk_evm_tokens from \"./1101/erc20.json\";\nimport polygon_zk_evm_testnet_tokens from \"./1442/erc20.json\";\nimport rsk_tokens from \"./30/erc20.json\";\nimport songbird_tokens from \"./19/erc20.json\";\nimport syscoin_tokens from \"./57/erc20.json\";\nimport telos_evm_tokens from \"./40/erc20.json\";\nimport velas_evm_tokens from \"./106/erc20.json\";\nimport arbitrum_signatures from \"./42161/erc20-signatures.json\";\nimport arbitrum_goerli_signatures from \"./421613/erc20-signatures.json\";\nimport astar_signatures from \"./592/erc20-signatures.json\";\nimport base_goerli_signatures from \"./84531/erc20-signatures.json\";\nimport bittorrent_signatures from \"./199/erc20-signatures.json\";\nimport bsc_signatures from \"./56/erc20-signatures.json\";\nimport cronos_signatures from \"./25/erc20-signatures.json\";\nimport energy_web_signatures from \"./246/erc20-signatures.json\";\nimport ethereum_signatures from \"./1/erc20-signatures.json\";\nimport ethereum_goerli_signatures from \"./5/erc20-signatures.json\";\nimport ethereum_rinkeby_signatures from \"./4/erc20-signatures.json\";\nimport ethereum_ropsten_signatures from \"./3/erc20-signatures.json\";\nimport ethereum_sepolia_signatures from \"./11155111/erc20-signatures.json\";\nimport fantom_signatures from \"./250/erc20-signatures.json\";\nimport flare_signatures from \"./14/erc20-signatures.json\";\nimport klaytn_signatures from \"./8217/erc20-signatures.json\";\nimport metis_signatures from \"./1088/erc20-signatures.json\";\nimport moonbeam_signatures from \"./1284/erc20-signatures.json\";\nimport optimism_signatures from \"./10/erc20-signatures.json\";\nimport optimism_goerli_signatures from \"./420/erc20-signatures.json\";\nimport polygon_signatures from \"./137/erc20-signatures.json\";\nimport polygon_zk_evm_signatures from \"./1101/erc20-signatures.json\";\nimport polygon_zk_evm_testnet_signatures from \"./1442/erc20-signatures.json\";\nimport rsk_signatures from \"./30/erc20-signatures.json\";\nimport songbird_signatures from \"./19/erc20-signatures.json\";\nimport syscoin_signatures from \"./57/erc20-signatures.json\";\nimport telos_evm_signatures from \"./40/erc20-signatures.json\";\nimport velas_evm_signatures from \"./106/erc20-signatures.json\";\n\nexport const tokens = {\n  42161: arbitrum_tokens,\n  421613: arbitrum_goerli_tokens,\n  592: astar_tokens,\n  84531: base_goerli_tokens,\n  199: bittorrent_tokens,\n  56: bsc_tokens,\n  25: cronos_tokens,\n  246: energy_web_tokens,\n  1: ethereum_tokens,\n  5: ethereum_goerli_tokens,\n  4: ethereum_rinkeby_tokens,\n  3: ethereum_ropsten_tokens,\n  11155111: ethereum_sepolia_tokens,\n  250: fantom_tokens,\n  14: flare_tokens,\n  8217: klaytn_tokens,\n  1088: metis_tokens,\n  1284: moonbeam_tokens,\n  10: optimism_tokens,\n  420: optimism_goerli_tokens,\n  137: polygon_tokens,\n  1101: polygon_zk_evm_tokens,\n  1442: polygon_zk_evm_testnet_tokens,\n  30: rsk_tokens,\n  19: songbird_tokens,\n  57: syscoin_tokens,\n  40: telos_evm_tokens,\n  106: velas_evm_tokens,\n};\n\nexport const signatures = {\n  42161: arbitrum_signatures,\n  421613: arbitrum_goerli_signatures,\n  592: astar_signatures,\n  84531: base_goerli_signatures,\n  199: bittorrent_signatures,\n  56: bsc_signatures,\n  25: cronos_signatures,\n  246: energy_web_signatures,\n  1: ethereum_signatures,\n  5: ethereum_goerli_signatures,\n  4: ethereum_rinkeby_signatures,\n  3: ethereum_ropsten_signatures,\n  11155111: ethereum_sepolia_signatures,\n  250: fantom_signatures,\n  14: flare_signatures,\n  8217: klaytn_signatures,\n  1088: metis_signatures,\n  1284: moonbeam_signatures,\n  10: optimism_signatures,\n  420: optimism_goerli_signatures,\n  137: polygon_signatures,\n  1101: polygon_zk_evm_signatures,\n  1442: polygon_zk_evm_testnet_signatures,\n  30: rsk_signatures,\n  19: songbird_signatures,\n  57: syscoin_signatures,\n  40: telos_evm_signatures,\n  106: velas_evm_signatures,\n};\n\nexport default {\n  tokens,\n  signatures,\n};\n","import { Registry } from \"../types\";\n\nconst REGISTRIES: Registry[] = [\n  {\n    name: \"ens\",\n    resolvers: {\n      forward: \"https://explorers.api.live.ledger.com/blockchain/v4/eth/ens/resolve/{name}\",\n      reverse:\n        \"https://explorers.api.live.ledger.com/blockchain/v4/eth/ens/reverse-resolve/{address}\",\n    },\n    signatures: {\n      forward: \"https://nft.api.live.ledger.com/v1/names/ens/forward/{name}?challenge={challenge}\",\n      reverse:\n        \"https://nft.api.live.ledger.com/v1/names/ens/reverse/{address}?challenge={challenge}\",\n    },\n    patterns: {\n      forward: new RegExp(\"\\\\.eth$\"),\n      reverse: new RegExp(\"^0x[0-9a-fA-F]{40}$\"),\n    },\n    coinTypes: [60],\n  },\n];\n\n/**\n * Method is voluntarly made async so it can be replaced by a backend call once implemented\n */\nexport const getRegistries = async (): Promise<Registry[]> => REGISTRIES;\n\n/**\n * Get an array of registries compatible with a given domain\n *\n * @param {string} domain\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const getRegistriesForDomain = async (domain: string): Promise<Registry[]> => {\n  const registries = await getRegistries();\n\n  return registries.filter(registry => registry.patterns.forward.test(domain));\n};\n\n/**\n * Get an array of registries compatible with a given address\n *\n * @param {string} address\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const getRegistriesForAddress = async (address: string): Promise<Registry[]> => {\n  const registries = await getRegistries();\n\n  return registries.filter(registry => registry.patterns.reverse.test(address));\n};\n","import axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\nimport { SupportedRegistries } from \"../types\";\nimport { getRegistries } from \"../registries\";\nimport { validateDomain } from \"../utils\";\n\n/**\n * Get an APDU to sign a domain resolution on the nano\n *\n * @param {string} domain\n * @param {SupportedRegistries} registryName\n * @param {string} challenge\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const signDomainResolution = async (\n  domain: string,\n  registryName: SupportedRegistries,\n  challenge: string,\n): Promise<string | null> => {\n  if (!validateDomain(domain)) {\n    throw new Error(\n      `Domains with more than 255 caracters or with unicode are not supported on the nano. Domain: ${domain}`,\n    );\n  }\n  const registries = await getRegistries();\n  const registry = registries.find(r => r.name === registryName);\n  if (!registry) return null;\n\n  const url = registry.signatures.forward\n    .replace(\"{name}\", domain)\n    .replace(\"{challenge}\", challenge);\n\n  return axios\n    .request<{ payload: string }>({\n      method: \"GET\",\n      url,\n    })\n    .then(({ data }) => data.payload)\n    .catch(error => {\n      /* istanbul ignore next: don't test logs */\n      if (error.status !== 404) {\n        log(\"domain-service\", \"failed to get APDU for a domain\", {\n          domain,\n          error,\n        });\n      }\n      return null;\n    });\n};\n\n/**\n * Get an APDU to sign an address resolve resolution on the nano\n *\n * @param {string} address\n * @param {SupportedRegistries} registryName\n * @param {string} challenge\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const signAddressResolution = async (\n  address: string,\n  registryName: SupportedRegistries,\n  challenge: string,\n): Promise<string | null> => {\n  const registries = await getRegistries();\n  const registry = registries.find(r => r.name === registryName);\n  if (!registry) return null;\n\n  const url = registry.signatures.reverse\n    .replace(\"{address}\", address)\n    .replace(\"{challenge}\", challenge);\n\n  return axios\n    .request<{ payload: string }>({\n      method: \"GET\",\n      url,\n    })\n    .then(({ data }) => data.payload)\n    .catch(error => {\n      /* istanbul ignore next: don't test logs */\n      if (error.status !== 404) {\n        log(\"domain-service\", \"failed to get APDU for an address\", {\n          address,\n          error,\n        });\n      }\n      return null;\n    });\n};\n","import { PromiseResult } from \"../types\";\n\n/**\n * Needed polyfill for Promise.allSettled as it doesn't exist on RN.\n */\nexport const allSettled = <T>(promises: Promise<T>[]): Promise<PromiseResult<T>[]> => {\n  return Promise.all(\n    promises.map(p => {\n      return p\n        .then(value => {\n          return {\n            status: \"fulfilled\" as const,\n            value,\n          };\n        })\n        .catch((reason: unknown) => {\n          return {\n            status: \"rejected\" as const,\n            reason,\n          };\n        });\n    }),\n  );\n};\n\n/**\n * Helper to know in advance if a domain is compatible with the nano\n *\n * @param domain string representing the domain\n * @returns {Boolean}\n */\nexport const validateDomain = (domain: string | undefined): boolean => {\n  if (typeof domain !== \"string\") {\n    return false;\n  }\n\n  const lengthIsValid = domain.length > 0 && Number(domain.length) < 30;\n  const containsOnlyValidChars = new RegExp(\"^[a-zA-Z0-9\\\\-\\\\_\\\\.]+$\").test(domain);\n\n  return lengthIsValid && containsOnlyValidChars;\n};\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype ContractMethod = {\n  payload: string;\n  signature: string;\n  plugin: string;\n  erc20OfInterest: string[];\n  abi: any;\n};\n\n/**\n * Retrieve the metadatas a given contract address and a method selector\n */\nexport const loadInfosForContractMethod = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<ContractMethod | undefined> => {\n  const { pluginBaseURL, extraPlugins } = getLoadConfig(userLoadConfig);\n\n  let data = {};\n\n  if (pluginBaseURL) {\n    const url = `${pluginBaseURL}/plugins/ethereum.json`;\n    data = await axios\n      .get(`${pluginBaseURL}/plugins/ethereum.json`)\n      .then((r) => r.data as any)\n      .catch((e) => {\n        log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n        return null;\n      });\n  }\n\n  if (extraPlugins) {\n    data = { ...data, ...extraPlugins };\n  }\n\n  if (!data) return;\n\n  const lcSelector = selector.toLowerCase();\n  const lcContractAddress = contractAddress.toLowerCase();\n\n  if (lcContractAddress in data) {\n    const contractSelectors = data[lcContractAddress];\n\n    if (lcSelector in contractSelectors) {\n      return {\n        payload: contractSelectors[lcSelector][\"serialized_data\"],\n        signature: contractSelectors[lcSelector][\"signature\"],\n        plugin: contractSelectors[lcSelector][\"plugin\"],\n        erc20OfInterest: contractSelectors[lcSelector][\"erc20OfInterest\"],\n        abi: contractSelectors[\"abi\"],\n      };\n    }\n  }\n};\n","import axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\nimport { signatures as signaturesByChainId } from \"@ledgerhq/cryptoassets/data/evm/index\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport { LoadConfig } from \"../types\";\n\nconst asContractAddress = (addr: string) => {\n  const a = addr.toLowerCase();\n  return a.startsWith(\"0x\") ? a : \"0x\" + a;\n};\n\nexport const findERC20SignaturesInfo = async (\n  userLoadConfig: LoadConfig,\n  chainId: number\n): Promise<string | null> => {\n  const { cryptoassetsBaseURL } = getLoadConfig(userLoadConfig);\n  if (!cryptoassetsBaseURL) return null;\n\n  const url = `${cryptoassetsBaseURL}/evm/${chainId}/erc20-signatures.json`;\n  const blob = await axios\n    .get<string>(url)\n    .then(({ data }) => {\n      if (!data || typeof data !== \"string\") {\n        throw new Error(\n          `ERC20 signatures for chainId ${chainId} file is malformed ${url}`\n        );\n      }\n      return data;\n    })\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n\n  return blob;\n};\n\n/**\n * Retrieve the token information by a given contract address if any\n */\nexport const byContractAddressAndChainId = (\n  contract: string,\n  chainId: number,\n  erc20SignaturesBlob?: string | null\n): ReturnType<API[\"byContractAndChainId\"]> => {\n  // If we are able to fetch data from s3 bucket that contains dynamic CAL\n  if (erc20SignaturesBlob) {\n    try {\n      return parse(erc20SignaturesBlob).byContractAndChainId(\n        asContractAddress(contract),\n        chainId\n      );\n    } catch (e) {\n      return get(chainId)?.byContractAndChainId(\n        asContractAddress(contract),\n        chainId\n      );\n    }\n  }\n\n  // the static fallback when dynamic cal is not provided\n  return get(chainId)?.byContractAndChainId(\n    asContractAddress(contract),\n    chainId\n  );\n};\n\nexport type TokenInfo = {\n  contractAddress: string;\n  ticker: string;\n  decimals: number;\n  chainId: number;\n  signature: Buffer;\n  data: Buffer;\n};\nexport type API = {\n  byContractAndChainId: (\n    addr: string,\n    id: number\n  ) => TokenInfo | null | undefined;\n  list: () => TokenInfo[];\n};\n\nconst parse = (erc20SignaturesBlob: string): API => {\n  const buf = Buffer.from(erc20SignaturesBlob, \"base64\");\n  const map = {};\n  const entries: TokenInfo[] = [];\n  let i = 0;\n\n  while (i < buf.length) {\n    const length = buf.readUInt32BE(i);\n    i += 4;\n    const item = buf.slice(i, i + length);\n    let j = 0;\n    const tickerLength = item.readUInt8(j);\n    j += 1;\n    const ticker = item.slice(j, j + tickerLength).toString(\"ascii\");\n    j += tickerLength;\n    const contractAddress = asContractAddress(\n      item.slice(j, j + 20).toString(\"hex\")\n    );\n    j += 20;\n    const decimals = item.readUInt32BE(j);\n    j += 4;\n    const chainId = item.readUInt32BE(j);\n    j += 4;\n    const signature = item.slice(j);\n    const entry: TokenInfo = {\n      ticker,\n      contractAddress,\n      decimals,\n      chainId,\n      signature,\n      data: item,\n    };\n    entries.push(entry);\n    map[String(chainId) + \":\" + contractAddress] = entry;\n    i += length;\n  }\n\n  return {\n    list: () => entries,\n    byContractAndChainId: (contractAddress, chainId) =>\n      map[String(chainId) + \":\" + contractAddress],\n  };\n};\n\n// this internal get() will lazy load and cache the data from the erc20 data blob\nconst get: (chainId: number) => API | null = (() => {\n  const cache: Record<number, API> = {};\n  return (chainId) => {\n    if (cache[chainId]) return cache[chainId];\n\n    const signatureBlob: string | undefined = signaturesByChainId[chainId];\n    if (!signatureBlob) return null;\n\n    const api = parse(signatureBlob);\n    cache[chainId] = api;\n    return api;\n  };\n})();\n","// This implements the resolution of a Transaction using Ledger's own API\nimport { log } from \"@ledgerhq/logs\";\nimport { Interface } from \"@ethersproject/abi\";\nimport {\n  signDomainResolution,\n  signAddressResolution,\n} from \"@ledgerhq/domain-service/signers/index\";\nimport {\n  LedgerEthTransactionResolution,\n  LedgerEthTransactionService,\n  LoadConfig,\n} from \"../types\";\nimport { byContractAddressAndChainId, findERC20SignaturesInfo } from \"./erc20\";\nimport { loadInfosForContractMethod } from \"./contracts\";\nimport { getNFTInfo, loadNftPlugin } from \"./nfts\";\nimport {\n  decodeTxInfo,\n  tokenSelectors,\n  nftSelectors,\n  mergeResolutions,\n} from \"../../utils\";\n\ntype PotentialResolutions = {\n  token: boolean | undefined;\n  nft: boolean | undefined;\n  externalPlugins: boolean | undefined;\n};\n\n/**\n * @ignore for external documentation\n *\n * Providing additionnal data for some transactions (Token or NFT related) can enable clear signing\n * of initially impossible to decode data.\n * This method will add necessary APDUs to the resolution paramter in order to provide this data to the nano app\n */\nconst getAdditionalDataForContract = async (\n  contractAddress: string,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: PotentialResolutions\n): Promise<Pick<LedgerEthTransactionResolution, \"nfts\" | \"erc20Tokens\">> => {\n  const resolution: Pick<\n    LedgerEthTransactionResolution,\n    \"nfts\" | \"erc20Tokens\"\n  > = {\n    nfts: [],\n    erc20Tokens: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftInfo = await getNFTInfo(\n      contractAddress,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (nftInfo) {\n      log(\n        \"ethereum\",\n        \"loaded nft info for \" +\n          nftInfo.contractAddress +\n          \" (\" +\n          nftInfo.collectionName +\n          \")\"\n      );\n      resolution.nfts.push(nftInfo.data);\n    } else {\n      log(\"ethereum\", \"couldn't load nft info for \" + contractAddress);\n    }\n  }\n\n  if (shouldResolve.token) {\n    const erc20SignaturesBlob = await findERC20SignaturesInfo(\n      loadConfig,\n      chainIdTruncated\n    );\n    const erc20Info = byContractAddressAndChainId(\n      contractAddress,\n      chainIdTruncated,\n      erc20SignaturesBlob\n    );\n\n    if (erc20Info) {\n      log(\n        \"ethereum\",\n        \"loaded erc20token info for \" +\n          erc20Info.contractAddress +\n          \" (\" +\n          erc20Info.ticker +\n          \")\"\n      );\n      resolution.erc20Tokens.push(erc20Info.data.toString(\"hex\"));\n    } else {\n      log(\"ethereum\", \"couldn't load erc20token info for \" + contractAddress);\n    }\n  }\n\n  return resolution;\n};\n\n/**\n * @ignore for external documentation\n *\n * Depending on the transaction, it might be necessary to load internal plugins in the nano app\n * in order to clear sign it.\n * This method will add necessary APDUs to the resolution parameter in order to load those internal plugins\n */\nconst loadNanoAppPlugins = async (\n  contractAddress: string,\n  selector: string,\n  decodedTx,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: PotentialResolutions\n): Promise<LedgerEthTransactionResolution> => {\n  let resolution: LedgerEthTransactionResolution = {\n    externalPlugin: [],\n    plugin: [],\n    nfts: [],\n    erc20Tokens: [],\n    domains: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftPluginPayload = await loadNftPlugin(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (nftPluginPayload) {\n      resolution.plugin.push(nftPluginPayload);\n    } else {\n      log(\n        \"ethereum\",\n        \"no NFT plugin payload for selector \" +\n          selector +\n          \" and address \" +\n          contractAddress\n      );\n    }\n  }\n\n  if (shouldResolve.externalPlugins) {\n    const contractMethodInfos = await loadInfosForContractMethod(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig\n    );\n\n    if (contractMethodInfos) {\n      const { plugin, payload, signature, erc20OfInterest, abi } =\n        contractMethodInfos;\n\n      if (plugin) {\n        log(\"ethereum\", \"found plugin for \" + selector);\n        resolution.externalPlugin.push({ payload, signature });\n      }\n\n      if (erc20OfInterest && erc20OfInterest.length && abi) {\n        const contract = new Interface(abi);\n        const args = contract.parseTransaction(decodedTx).args;\n\n        for (const path of erc20OfInterest) {\n          const erc20ContractAddress = path.split(\".\").reduce((value, seg) => {\n            if (seg === \"-1\" && Array.isArray(value)) {\n              return value[value.length - 1];\n            }\n            return value[seg];\n          }, args) as unknown as string; // impossible(?) to type correctly as the initializer is different from the returned type\n\n          const externalPluginResolution = await getAdditionalDataForContract(\n            erc20ContractAddress,\n            chainIdTruncated,\n            loadConfig,\n            {\n              nft: false,\n              externalPlugins: false,\n              token: true, // enforcing resolution of tokens for external plugins that need info on assets (e.g. for a swap)\n            }\n          );\n          resolution = mergeResolutions([resolution, externalPluginResolution]);\n        }\n      }\n    } else {\n      log(\"ethereum\", \"no infos for selector \" + selector);\n    }\n  }\n\n  return resolution;\n};\n\n/**\n * @ignore for external documentation\n *\n * In charge of collecting the different APDUs necessary for clear signing\n * a transaction based on a specified configuration.\n */\nconst resolveTransaction: LedgerEthTransactionService[\"resolveTransaction\"] =\n  async (rawTxHex, loadConfig, resolutionConfig) => {\n    const rawTx = Buffer.from(rawTxHex, \"hex\");\n    const { decodedTx, chainIdTruncated } = decodeTxInfo(rawTx);\n    const { domains } = resolutionConfig;\n\n    const contractAddress = decodedTx.to;\n    const selector =\n      decodedTx.data.length >= 10 && decodedTx.data.substring(0, 10);\n\n    const resolutions: Partial<LedgerEthTransactionResolution>[] = [];\n    if (selector) {\n      const shouldResolve: PotentialResolutions = {\n        token: resolutionConfig.erc20 && tokenSelectors.includes(selector),\n        nft: resolutionConfig.nft && nftSelectors.includes(selector),\n        externalPlugins: resolutionConfig.externalPlugins,\n      };\n\n      const pluginsResolution = await loadNanoAppPlugins(\n        contractAddress,\n        selector,\n        decodedTx,\n        chainIdTruncated,\n        loadConfig,\n        shouldResolve\n      );\n      if (pluginsResolution) {\n        resolutions.push(pluginsResolution);\n      }\n\n      const contractResolution = await getAdditionalDataForContract(\n        contractAddress,\n        chainIdTruncated,\n        loadConfig,\n        shouldResolve\n      );\n      if (contractResolution) {\n        resolutions.push(contractResolution);\n      }\n    }\n\n    // Passthrough to be accessible to the Domains module\n    if (domains) {\n      const domainResolutions: Partial<LedgerEthTransactionResolution> = {\n        domains,\n      };\n      resolutions.push(domainResolutions);\n    }\n\n    return mergeResolutions(resolutions);\n  };\n\nexport default {\n  resolveTransaction,\n  signDomainResolution,\n  signAddressResolution,\n} as LedgerEthTransactionService;\n","import type { LoadConfig } from \"../types\";\n\nconst defaultLoadConfig: Required<LoadConfig> = {\n  nftExplorerBaseURL: \"https://nft.api.live.ledger.com/v1/ethereum\",\n  pluginBaseURL: \"https://cdn.live.ledger.com\",\n  extraPlugins: null,\n  cryptoassetsBaseURL: \"https://cdn.live.ledger.com/cryptoassets\",\n};\n\nexport function getLoadConfig(userLoadConfig?: LoadConfig): LoadConfig {\n  return {\n    ...defaultLoadConfig,\n    ...userLoadConfig,\n  };\n}\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype NftInfo = {\n  contractAddress: string;\n  collectionName: string;\n  data: string;\n};\n\ntype BackendResponse = {\n  payload: string;\n};\n\nexport const getNFTInfo = async (\n  contractAddress: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<NftInfo | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}`;\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then((r) => r.data)\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  // APDU response specification: https://ledgerhq.atlassian.net/wiki/spaces/WALLETCO/pages/3269984297/NFT-1+NFT+Backend+design#NFT-Metadata-BLOB\n  const payload = response[\"payload\"];\n  // Collection name length position: 3rd byte -> caracter 4 to 6\n  const collectionNameLength = parseInt(payload.slice(4, 6), 16);\n  const collectionNameHex = payload.substr(6, collectionNameLength * 2);\n  const collectionName = collectionNameHex\n    .match(/.{2}/g) // split every 2 characters\n    ?.reduce(\n      (acc, curr) => (acc += String.fromCharCode(parseInt(curr, 16))),\n      \"\"\n    ); // convert hex to string\n\n  return {\n    contractAddress: contractAddress,\n    collectionName: collectionName || \"\",\n    data: payload,\n  };\n};\n\nexport const loadNftPlugin = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig\n): Promise<string | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}/plugin-selector/${selector}`;\n\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then((r) => r.data)\n    .catch((e) => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  const payload = response[\"payload\"];\n  return payload;\n};\n","import { encode, decode } from \"@ethersproject/rlp\";\nimport { BigNumber } from \"bignumber.js\";\nimport { LedgerEthTransactionResolution } from \"./services/types\";\n\nexport function splitPath(path: string): number[] {\n  const result: number[] = [];\n  const components = path.split(\"/\");\n  components.forEach((element) => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\nexport function hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nexport function maybeHexBuffer(\n  str: string | null | undefined\n): Buffer | null | undefined {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nexport const decodeTxInfo = (rawTx: Buffer) => {\n  const VALID_TYPES = [1, 2];\n  const txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n  const rlpData = txType === null ? rawTx : rawTx.slice(1);\n  const rlpTx = decode(rlpData).map((hex) => Buffer.from(hex.slice(2), \"hex\"));\n  let chainIdTruncated = 0;\n  const rlpDecoded = decode(rlpData);\n\n  let decodedTx;\n  if (txType === 2) {\n    // EIP1559\n    decodedTx = {\n      data: rlpDecoded[7],\n      to: rlpDecoded[5],\n      chainId: rlpTx[0],\n    };\n  } else if (txType === 1) {\n    // EIP2930\n    decodedTx = {\n      data: rlpDecoded[6],\n      to: rlpDecoded[4],\n      chainId: rlpTx[0],\n    };\n  } else {\n    // Legacy tx\n    decodedTx = {\n      data: rlpDecoded[5],\n      to: rlpDecoded[3],\n      // Default to 1 for non EIP 155 txs\n      chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\"),\n    };\n  }\n\n  const chainIdSrc = decodedTx.chainId;\n  let chainId = new BigNumber(0);\n  if (chainIdSrc) {\n    // Using BigNumber because chainID could be any uint256.\n    chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n    const chainIdTruncatedBuf = Buffer.alloc(4);\n    if (chainIdSrc.length > 4) {\n      chainIdSrc.copy(chainIdTruncatedBuf);\n    } else {\n      chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n    }\n    chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n  }\n\n  let vrsOffset = 0;\n  if (txType === null && rlpTx.length > 6) {\n    const rlpVrs = Buffer.from(encode(rlpTx.slice(-3)).slice(2), \"hex\");\n\n    vrsOffset = rawTx.length - (rlpVrs.length - 1);\n\n    // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n    if (rlpVrs[0] > 0xf7) {\n      // Increment vrsOffset to account for that extra byte.\n      vrsOffset++;\n\n      // Compute size of the list length.\n      const sizeOfListLen = rlpVrs[0] - 0xf7;\n\n      // Increase rlpOffset by the size of the list length.\n      vrsOffset += sizeOfListLen - 1;\n    }\n  }\n\n  return {\n    decodedTx,\n    txType,\n    chainId,\n    chainIdTruncated,\n    vrsOffset,\n  };\n};\n\n/**\n * @ignore for the README\n *\n * Helper to convert an integer as a hexadecimal string with the right amount of digits\n * to respect the number of bytes given as parameter\n *\n * @param int Integer\n * @param bytes Number of bytes it should be represented as (1 byte = 2 caraters)\n * @returns The given integer as an hexa string padded with the right number of 0\n */\nexport const intAsHexBytes = (int: number, bytes: number): string =>\n  int.toString(16).padStart(2 * bytes, \"0\");\n\n/**\n * @ignore for the README\n *\n * List of selectors (hexadecimal representation of the used method's signature) related to\n * ERC20 (Tokens), ERC721/ERC1155 (NFT).\n * You can verify and/or get more info about them on http://4byte.directory\n */\n\nexport enum ERC20_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  TRANSFER = \"0xa9059cbb\",\n}\n\nexport enum ERC721_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  TRANSFER_FROM = \"0x23b872dd\",\n  SAFE_TRANSFER_FROM = \"0x42842e0e\",\n  SAFE_TRANSFER_FROM_WITH_DATA = \"0xb88d4fde\",\n}\n\nexport enum ERC1155_CLEAR_SIGNED_SELECTORS {\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  SAFE_TRANSFER_FROM = \"0xf242432a\",\n  SAFE_BATCH_TRANSFER_FROM = \"0x2eb2c2d6\",\n}\n\nexport const tokenSelectors = Object.values(ERC20_CLEAR_SIGNED_SELECTORS);\nexport const nftSelectors = [\n  ...Object.values(ERC721_CLEAR_SIGNED_SELECTORS),\n  ...Object.values(ERC1155_CLEAR_SIGNED_SELECTORS),\n];\n\nexport const mergeResolutions = (\n  resolutionsArray: Partial<LedgerEthTransactionResolution>[]\n): LedgerEthTransactionResolution => {\n  const mergedResolutions: LedgerEthTransactionResolution = {\n    nfts: [],\n    erc20Tokens: [],\n    externalPlugin: [],\n    plugin: [],\n    domains: [],\n  };\n\n  for (const resolutions of resolutionsArray) {\n    for (const key in resolutions) {\n      mergedResolutions[key].push(...resolutions[key]);\n    }\n  }\n\n  return mergedResolutions;\n};\n"],"names":["erc20_json_1","__importDefault","require","erc20_json_2","erc20_json_3","erc20_json_4","erc20_json_5","erc20_json_6","erc20_json_7","erc20_json_8","erc20_json_9","erc20_json_10","erc20_json_11","erc20_json_12","erc20_json_13","erc20_json_14","erc20_json_15","erc20_json_16","erc20_json_17","erc20_json_18","erc20_json_19","erc20_json_20","erc20_json_21","erc20_json_22","erc20_json_23","erc20_json_24","erc20_json_25","erc20_json_26","erc20_json_27","erc20_json_28","erc20_signatures_json_1","erc20_signatures_json_2","erc20_signatures_json_3","erc20_signatures_json_4","erc20_signatures_json_5","erc20_signatures_json_6","erc20_signatures_json_7","erc20_signatures_json_8","erc20_signatures_json_9","erc20_signatures_json_10","erc20_signatures_json_11","erc20_signatures_json_12","erc20_signatures_json_13","erc20_signatures_json_14","erc20_signatures_json_15","erc20_signatures_json_16","erc20_signatures_json_17","erc20_signatures_json_18","erc20_signatures_json_19","erc20_signatures_json_20","erc20_signatures_json_21","erc20_signatures_json_22","erc20_signatures_json_23","erc20_signatures_json_24","erc20_signatures_json_25","erc20_signatures_json_26","erc20_signatures_json_27","erc20_signatures_json_28","exports","default","tokens","signatures","REGISTRIES","name","resolvers","forward","reverse","patterns","RegExp","coinTypes","getRegistries","__awaiter","domain","filter","registry","test","address","axios_1","logs_1","registries_1","utils_1","signDomainResolution","registryName","challenge","validateDomain","Error","find","r","url","replace","request","method","then","_ref","data","payload","catch","error","status","log","signAddressResolution","_ref2","promises","Promise","all","map","p","value","reason","lengthIsValid","length","Number","containsOnlyValidChars","loadConfig_1","loadInfosForContractMethod","contractAddress","selector","chainId","userLoadConfig","pluginBaseURL","extraPlugins","getLoadConfig","get","e","String","Object","assign","lcSelector","toLowerCase","lcContractAddress","contractSelectors","signature","plugin","erc20OfInterest","abi","index_1","asContractAddress","addr","a","startsWith","findERC20SignaturesInfo","cryptoassetsBaseURL","byContractAddressAndChainId","contract","erc20SignaturesBlob","parse","byContractAndChainId","_a","_b","buf","Buffer","from","entries","i","readUInt32BE","item","slice","j","tickerLength","readUInt8","ticker","toString","decimals","entry","push","list","cache","signatureBlob","api","abi_1","erc20_1","contracts_1","nfts_1","getAdditionalDataForContract","chainIdTruncated","loadConfig","shouldResolve","resolution","nfts","erc20Tokens","nft","nftInfo","getNFTInfo","collectionName","token","erc20Info","resolveTransaction","rawTxHex","resolutionConfig","rawTx","decodedTx","decodeTxInfo","domains","to","substring","resolutions","erc20","tokenSelectors","includes","nftSelectors","externalPlugins","pluginsResolution","loadNanoAppPlugins","externalPlugin","nftPluginPayload","loadNftPlugin","contractMethodInfos","args","Interface","parseTransaction","path","erc20ContractAddress","split","reduce","seg","Array","isArray","externalPluginResolution","mergeResolutions","contractResolution","domainResolutions","defaultLoadConfig","nftExplorerBaseURL","response","collectionNameLength","parseInt","substr","match","acc","curr","fromCharCode","rlp_1","bignumber_js_1","hexBuffer","str","result","forEach","element","number","isNaN","txType","rlpData","rlpTx","decode","hex","rlpDecoded","chainIdSrc","BigNumber","chainIdTruncatedBuf","alloc","copy","vrsOffset","rlpVrs","encode","ERC20_CLEAR_SIGNED_SELECTORS","ERC721_CLEAR_SIGNED_SELECTORS","ERC1155_CLEAR_SIGNED_SELECTORS","intAsHexBytes","int","bytes","padStart","values","resolutionsArray","mergedResolutions","key"],"sourceRoot":""}